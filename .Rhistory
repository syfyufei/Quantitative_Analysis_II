library(foreign)
dat <- read.dta("garrum6.dta")
getwd()
setwd("E:/SynologyDrive/Github/Quantitative_Analysis_II/slide/week13")
setwd("E:/SynologyDrive/Github/Quantitative_Analysis_II/slides/week13")
library(foreign)
dat <- read.dta("garrum6.dta")
library(plm)
library(plm)
mp <- plm(gdp ~ oild + demand + corp + leftlab + clint, data=dat, index =
"country", model = "pooling")
summary(mp)
library(foreign)
dat <- read.dta("garrum6.dta")
library(plm)
mp <- plm(gdp ~ oild + demand + corp + leftlab + clint, data=dat, index =
"country", model = "pooling")
summary(mp)
M0 <- lm(gdp ~ oild + demand + corp + leftlab + clint, data=dat)
summary(M0)
mf <- plm(gdp ~ oild + demand + corp + leftlab + clint, data=dat, index =
"country", model = "within")
summary(mf)
# F-test manually
# H0: u=0
df1 <- df.residual(mp)-df.residual(mf) # number of dummies K-1
df2 <- df.residual(mf)                 # degree of freedom of fixed effect model (N-K-1)
ssrp <- sum(resid(mp)^2)               # sum of residual square of pooling model
ssrf <- sum(resid(mf)^2)               # sum of residual square of fixed effect model
fQuant <- df2*(ssrp-ssrf)/ssrf/df1
pf(fQuant, df1, df2, lower.tail=FALSE)
# significant means reject H0, ie u#0, so fixed effect model is appropriate
# F-test in a function
pFtest(mf, mp)
mr <- plm(gdp ~ oild + demand + corp + leftlab + clint, data=dat, index =
"country", model = "random") #随机效应模型
summary(mr)
# Hausmen test manually
# H0 Re is appropriate, fe=re, re is more efficient
# Ha Re is inappropriate, fe#re, re is biased/inconsistent
mfB <- coef(mf)[1:5]
mrB <- coef(mr)[2:6]
mfV <- vcov(mf)[1:5,1:5]
mrV <- vcov(mr)[2:6,2:6]
hQuant <- t(mfB-mrB)%*%solve(mfV-mrV)%*%(mfB-mrB)
hQuant
pchisq(hQuant, 5, lower.tail=FALSE)
phtest(mf, mr)
#PCSE manually
mOLS <- lm(gdp ~ oild + demand + corp + leftlab + clint, data=dat)
summary(mOLS)
nK <- length(unique(dat$country))
nT <- length(unique(dat$year))
E <- matrix(resid(mOLS), nrow=nT, ncol=nK)
S <- t(E)%*%E/nT
IT <- diag(nT)
Omega <- S%x%IT
X <- model.matrix(mOLS)
XXinv <- solve(t(X)%*%X)
middle <- t(X)%*%Omega%*%X
PCSE <- sqrt(diag(XXinv %*% middle %*% XXinv))
View(dat)
library(pcse)
mPCSE <- pcse(mOLS, dat$country, dat$year)
summary(mPCSE)
library(pcse)
install.packages('pcse')
install.packages('panelAR')
install.packages('pcse')
n <- 500
Sys.setenv(lang = 'en')
n <- 500
y <- rep(NA, n+1)
y[1] <- 0
delta=2
u <- rnorm(n,0,1)
for(i in 2:(n+1)){
y[i] <- y[i-1] + delta + u[i]
}
y1 <- y[2:(n+1)]
for(i in 2:(n+1)){
y[i] <- y[i-1] + u[i]
}
y2 <- y[2:(n+1)]
par(mfrow=c(1,2), mar=c(3,3,3,1), mgp=c(1.5,0.2,0), tcl=-0.2)
plot(1:500, y1, type="l", ylab="Y", xlab="Time", main="Random Walk with Drift")
plot(1:500, y2, type="l", ylab="Y", xlab="Time", main="Random Walk without Drift")
abline(h=0, lty=2)
n <- 500
y <- rep(NA, n+1)
y[1] <- 0
delta=2
u <- rnorm(n,0,1)
for(i in 2:(n+1)){
y[i] <- y[i-1] + u[i]
}
y <- y[2:(n+1)]
n <- 500
x <- rep(NA, n+1)
x[1] <- 0
delta=2
u <- rnorm(n,0,1)
for(i in 2:(n+1)){
x[i] <- x[i-1] + u[i]
}
x <- x[2:(n+1)]
M1 <- lm(y ~ x)
library(lmtest)
dwtest(M1)
dwTest <- function(fit){
res <- residuals(fit)
n <- length(res)
d <- sum((res[2:n] - res[1:(n-1)])^2)/sum(res^2)
return(d)
}
library(tseries)
adf.test(na.exclude(y))
n <- 50
y <- rep(NA, n+1)
y[1:2] <- 0
mu <- 2
beta1 <- 0.3
beta2 <- 0.6
u <- rnorm(n,0,1)
for(i in 2:(n+1)){
y[i] <- mu + beta1 * u[i] + beta2*u[i-1]
}
y1 <- y[2:(n+1)]
n <- 50
y <- rep(NA, n+2)
y[1:2] <- 0
mu <- 2
beta1 <- 0.3
beta2 <- 0.6
beta3 <- 0.7
for(i in 3:(n+2)){
y[i] <- mu + beta1 * u[i] + beta2*u[i-1] + beta3*u[i-2]
}
y2 <- y[3:(n+2)]
par(mfrow=c(1,2), mar=c(3,3,3,1), mgp=c(1.5,0.2,0), tcl=-0.2)
plot(1:50, y1, type="l", ylab="Y", xlab="Time", main="MA(1)")
plot(1:50, y2, type="l", ylab="Y", xlab="Time", main="MA(2)")
M01 <- arima(y, order=c(1,2,1))
M02 <- arima(y, order=c(1,1,1))
AIC(M01)
AIC(M02)
?arima()
y
par(mfrow=c(1,2), mar=c(3,3,3,1), mgp=c(1.5,0.2,0), tcl=-0.2)
plot(1:50, y1, type="l", ylab="Y", xlab="Time", main="MA(1)")
plot(1:50, y2, type="l", ylab="Y", xlab="Time", main="MA(2)")
par(mfrow=c(1,2), mar=c(3,3,3,1), mgp=c(1.5,0.2,0), tcl=-0.2)
plot(1:500, y1, type="l", ylab="Y", xlab="Time", main="Random Walk with Drift")
plot(1:500, y2, type="l", ylab="Y", xlab="Time", main="Random Walk without Drift")
abline(h=0, lty=2)
acf(y)
?acf
library(foreign)
getwe
getwd()
dat <- read.dta("/slides/week11/temp.dta")
dat <- read.dta("./slides/week11/temp.dta")
attach(dat)
M1 <- lm(temp ~ year, data=dat)
pdf("fig04.pdf", width=5, height=3.5)
par(mar=c(3,3,1,1), mgp=c(2,0.2,0),tcl=-0.2)
plot(x=year, y=temp, type="l", col=4)
abline(lm(temp~year), col=2)
dev.off()
res <- residuals(M1)
yhat <- fitted(M1)
pdf("fig05.pdf", width=5, height=3.5)
par(mar=c(3,3,1,1), mgp=c(2,0.2,0),tcl=-0.2)
plot(x=yhat, y=res, ylim=c(-0.6, 0.6), xlab="fitted values", ylab="residuals")
abline(h=0, lty=2, col=2)
#lines(lowess(res ~ yhat, f=1/3), col=4)
dev.off()
pdf("fig06.pdf", width=5, height=3.5)
par(mar=c(3,3,1,1), mgp=c(2,0.2,0),tcl=-0.2)
plot(x=yhat, y=res, ylim=c(-0.6, 0.6), xlab="fitted values", ylab="residuals")
abline(h=0, lty=2, col=2)
lines(lowess(res ~ yhat, f=1/3), col=4)
dev.off()
library(tseries)
runs.test(as.factor(sign(res)))
chk <- res>0
n <- length(chk)
r <- 1+ sum(chk[-1] !=chk[-n])
n1 <- sum(chk)
n2 <- n-sum(chk)
mu <- (2*n1*n2/(n1+n2))+1
s <- sqrt((2*n1*n2*(2*n1*n2-n1-n2))/((n1+n2)^2*(n1+n2-1)))
z <- (r - mu)/s
z
2*pnorm(-abs(z))
pdf("fig07.pdf", width=5, height=3.5)
par(mar=c(3,3,1,1), mgp=c(2,0.2,0),tcl=-0.2)
print(acf(temp, lag.max=15))
dev.off()
pdf("fig08.pdf", width=5, height=3.5)
par(mar=c(3,3,1,1), mgp=c(2,0.2,0),tcl=-0.2)
print(pacf(temp, lag.max=15))
dev.off()
M1 <- lm(temp ~ year, data=dat)
res <- residuals(M1)
alpha <- cor(res[2:n], res[1:(n-1)])
alpha
yearF <- with(dat, year - alpha*c(NA, year[1:(n-1)]))
tempF <- with(dat, temp - alpha*c(NA, temp[1:(n-1)]))
M2 <- lm(tempF ~ yearF)
turkey <- read.csv("turkey.csv")
turkey <- na.exclude(turkey)
n <- dim(turkey)[1]
turkey <- read.csv("./week11/slides/turkey.csv")
turkey <- read.csv("./slides/week11/turkey.csv")
turkey <- na.exclude(turkey)
n <- dim(turkey)[1]
M3 <- lm(polity ~ gdp + open, data=turkey)
summary(M3)
res <- residuals(M3)
alpha <- cor(res[2:n], res[1:(n-1)])
pdf("turkeyAC.pdf", width=5, height=3.5)
par(mar=c(3,3,1,1), mgp=c(2,0.2,0),tcl=-0.2)
acf(turkey$polity)
dev.off()
pdf("turkeyPAC.pdf", width=5, height=3.5)
par(mar=c(3,3,1,1), mgp=c(2,0.2,0),tcl=-0.2)
pacf(turkey$polity)
dev.off()
pdf("turkeyCC.pdf", width=5, height=3.5)
par(mar=c(3,3,3,1), mgp=c(2,0.2,0),tcl=-0.2)
ccf(x=turkey$gdp, y=turkey$polity)
dev.off()
attach(turkey)
polF <- polity - alpha*c(NA, polity[1:(n-1)])
gdpF <- gdp - alpha*c(NA, gdp[1:(n-1)])
openF <- open - alpha*c(NA, open[1:(n-1)])
M4 <- lm(polF ~ gdpF + openF)
summary(M4)
runs.test(as.factor(sign(res)))
n <- dim(turkey)[1]
View(turkey)
M3 <- lm(polity ~ gdp + open, data=turkey)
summary(M3)
res <- residuals(M3)
alpha <- cor(res[2:n], res[1:(n-1)])
pdf("turkeyAC.pdf", width=5, height=3.5)
par(mar=c(3,3,1,1), mgp=c(2,0.2,0),tcl=-0.2)
acf(turkey$polity)
dev.off()
pdf("turkeyPAC.pdf", width=5, height=3.5)
par(mar=c(3,3,1,1), mgp=c(2,0.2,0),tcl=-0.2)
pacf(turkey$polity)
dev.off()
set.seed(431243)
library(arm)
group <- rep(1:10, rep(10,10))
u.all <- rnorm(10,2,1)[group]
g0 <- -1
g1 <- 0.5
sigma.a <- 1
mu.a <- mean(g0 + g1*u.all + sigma.a)
mu.b <- 3
sigma.b <- 4
rho <- 0.56
Sigma.ab <- array (c(sigma.a^2, rho*sigma.a*sigma.b,
rho*sigma.a*sigma.b, sigma.b^2), c(2,2))
sigma.y <- 1
ab <- mvrnorm (10, c(mu.a,mu.b), Sigma.ab)
a <- ab[,1]
b <- ab[,2]
x <- rnorm (100)
y <- rnorm (100, a[group] + b*x, sigma.y)
y2 <- rbinom(100, size=1, prob=invlogit(a[group] + b*x))
library(foreign)
dat <- cbind.data.frame(y, y2, x, u=u.all, group)
write.dta(dat, file="dat.dta")
M0 <- lmer(y ~ 1 + (1|group))  # vary intercept
display(M0)
library(sjstats)
icc(M0)
M1 <- lmer(y ~ x + (1|group))
display(M1)
icc(M1)
M1 <- lmer(y ~ x + (1|group))  # 加入自变量
display(M1)
icc(M1)
fixef(M0)
coef(M0)
M2 <- lmer(y ~ x + (1+x|group))
display(M2)
?lmer
M3 <- lmer(y ~ x + u.all + (1+x|group))
display(M3)
library(rstanarm)
options(mc.cores = parallel::detectCores())
BM3 <- stan_lmer(y ~ x + u.all + (1+x|group))
summary(BM3)
print(BM3)
coef(M1)
fixef(M1)
ranef(M1)
se.fixef(M1) # effcet的se
se.ranef(M1)
se.coef(M1)
fixef(M1)["x"] + 1.96*c(-1,1)*se.fixef(M1)["x"]
coef(M1)$group[5,"(Intercept)"] + 2*c(-1,1)*se.ranef(M1)$group[5]
ranef(M1)$group[5,"(Intercept)"] + 2*c(-1,1)*se.ranef(M1)$group[5]
pooled <- lm(y ~ x)
nopooled <- lm(y ~ x + factor(group))
a.hat.M1 <- coef(M1)$group[,"(Intercept)"]
b.hat.M1 <- coef(M1)$group[,"x"]
par(mfrow=c(3,4), mar=c(3,3,3,0.5),mgp=c(2,0.2,0),tcl=-0.2)
for(j in 1:10){
plot(x[group==j], y[group==j], xlim=c(-3,3), ylim=c(-12,12),
xlab="x", ylab="y", main=paste("group = ", j, sep=""))
curve(coef(pooled)["(Intercept)"] + coef(pooled)["x"]*x,
col="red", add=TRUE)
curve(coef(nopooled)[j+1] + coef(nopooled)["x"]*x,
col="forestgreen", add=TRUE)
curve(a.hat.M1[j] + b.hat.M1[j]*x, lwd=1, col="black", add=TRUE)
}
a.hat.M2 <- coef(M2)$group[,"(Intercept)"]
b.hat.M2 <- coef(M2)$group[,"x"]
par(mfrow=c(3,4), mar=c(3,3,3,0.5),mgp=c(2,0.2,0),tcl=-0.2)
for(j in 1:10){
plot(x[group==j], y[group==j], xlim=c(-3,3), ylim=c(-12,12),
xlab="x", ylab="y", main=paste("group = ", j, sep=""))
curve(a.hat.M2[j] + b.hat.M2[j]*x, lwd=1, col="black", add=TRUE)
}
x.new <- 3
sigma.y.hat <- sigma.hat(M1)$sigma$data
coef.hat <- as.matrix(coef(M2)$group[5,])
y.tilde <- rnorm(1, coef.hat %*% c(1,x.new), sigma.y.hat)
n.sims <- 1000
sigma.y.hat <- sigma.hat(M1)$sigma$data
coef.hat <- as.matrix(coef(M2)$group[5,])
y.tilde <- rnorm(n.sims, coef.hat %*% c(1,x.new), sigma.y.hat)
quantile(y.tilde, probs=c(0.025,0.25,0.5,0.75,0.975))
getwd()
library(foreign)
dat <- read.dta('./quiz02/ts.dta')
View(dat)
pdf("tsAcf.pdf", width=5, height=3.5)
par(mar=c(3,3,1,1), mgp=c(2,0.2,0),tcl=-0.2)
acf(dat$ts)
dev.off()
pdf("tsPAcf.pdf", width=5, height=3.5)
par(mar=c(3,3,1,1), mgp=c(2,0.2,0),tcl=-0.2)
pacf(dat$ts)
dev.off()
arima(dat)
arima(dat$ts)
y
print(i)
for (i in 1:5) {
print(i)
for (j in 1:5){
for (k in 1:5){
arima(dat$ts, order=c(i,j,k))
}
}
}
for (i in 1:5) {
print(i)
for (j in 1:5){
for (k in 1:5){
print(arima(dat$ts, order=c(i,j,k)))
}
}
}
pring(AIC(M0), i, j,k)
for (i in 1:5) {
for (j in 1:5){
for (k in 1:5){
M0 <- arima(dat$ts, order=c(i,j,k))
print(AIC(M0), i, j,k)
}
}
}
print(AIC(M0)+i+j+k)
for (i in 1:5) {
for (j in 1:5){
for (k in 1:5){
M0 <- arima(dat$ts, order=c(i,j,k))
print(AIC(M0)+i+j+k)
}
}
}
for (i in 1:5) {
for (j in 1:5){
for (k in 1:5){
M0 <- arima(dat$ts, order=c(i,j,k))
print(i, j, k)
print(AIC(M0))
}
}
}
for (i in 1:5) {
for (j in 1:5){
for (k in 1:5){
M0 <- arima(dat$ts, order=c(i,j,k))
print(i)
print(j)
pring(k)
print(AIC(M0))
}
}
}
for (i in 1:5) {
for (j in 1:5){
for (k in 1:5){
M0 <- arima(dat$ts, order=c(i,j,k))
print(i)
print(j)
print(k)
print(AIC(M0))
}
}
}
df <- data.frame("hi", "bye")
View(df)
df <- data.frame(hi, bye)
# arima(dat$ts)
aic_list <- data.frame("I", "J", 'K', 'AIC')
View(aic_list)
aic <- AIC(M0)
aic_now <- data.frame(i, j, k, AIC(M0))
aic_now <- data.frame(i, j, k, AIC(M0))
View(aic_now)
# arima(dat$ts)
aic_list <- data.frame(i, j, k, AIC(M0))
for (i in 1:5) {
for (j in 1:5){
for (k in 1:5){
M0 <- arima(dat$ts, order=c(i,j,k))
aic <- AIC(M0)
aic_now <- data.frame(i, j, k, AIC(M0))
merge(aic_list, aic_now)
# print(i)
# print(j)
# print(k)
# print(AIC(M0))
}
}
}
View(aic_list)
View(aic_now)
library(tidyverse)
dat1 <- read_csv('./quiz02/aclpData.csv')
View(dat1)
attach(dat1)
View(dat1)
View(dat1)
group <- rep(1:10, rep(10,10))
u.all <- rnorm(10,2,1)[group]
g0 <- -1
g1 <- 0.5
sigma.a <- 1
mu.a <- mean(g0 + g1*u.all + sigma.a)
mu.b <- 3
sigma.b <- 4
rho <- 0.56
Sigma.ab <- array (c(sigma.a^2, rho*sigma.a*sigma.b,
rho*sigma.a*sigma.b, sigma.b^2), c(2,2))
sigma.y <- 1
ab <- mvrnorm (10, c(mu.a,mu.b), Sigma.ab)
a <- ab[,1]
b <- ab[,2]
x <- rnorm (100)
y <- rnorm (100, a[group] + b*x, sigma.y)
y2 <- rbinom(100, size=1, prob=invlogit(a[group] + b*x))
dat <- cbind.data.frame(y, y2, x, u=u.all, group)
View(dat)
M0 <- lmer(y ~ 1 + (1|group))  # vary intercept
display(M0)
library(sjstats)
icc(M0)  # 看下面那个icc。不算太高也不算太低，0.3为阈值
fixef(M0)   # 第一层系数
range(M0) # 第二层
coef(M0) # 两层相加
M1 <- lmer(y ~ x + (1|group))  # 加入自变量
display(M1)
icc(M1)
M2 <- lmer(y ~ x + (1+x|group))
display(M2)
icc(M2)
M3 <- lmer(y ~ x + u.all + (1+x|group))  # 令人难懂
?u.all
??u.all
M1 <- lmer(gdp ~ REG + (1 + REG | group))  # 令人难懂
M1 <- lmer(gdp ~ REG + (1 + REG | group), data = dat1)  # 令人难懂
M1 <- lmer(gdp ~ REG + (1 + REG | group), data = dat1)  # 令人难懂
dat2 <- na.omit(dat1)
attach(dat2)
M1 <- lmer(gdp ~ REG + (1 + REG | group), data = dat1)  # 令人难懂
View(dat2)
M1 <- lmer(gdp ~ REG + (1 + REG | group), data = dat2)  # 令人难懂
dat1 <- read_csv('./quiz02/aclpData.csv')
dat2 <- na.omit(dat1)
attach(dat2)
M1 <- lmer(gdp ~ REG + (1 + REG | group), data = dat2)  # 令人难懂
M1 <- stan_lmer(gdp ~ REG + (1 + REG | group), data = dat2)  # 令人难懂
M1 <- lmer(gdp ~ as.factor(REG) + (1 + as.factor(REG) | group), data = dat2)  # 令人难懂
dat1 <- read_csv('./quiz02/aclpData.csv')
dat2 <- na.omit(dat1)
attach(dat2)
M1 <- lmer(gdp ~ REG + (1 + as.factor(REG) | group), data = dat2)  # 令人难懂
M1 <- lmer(log(gdp) ~ REG + (1 + REG | group), data = dat2)  # 令人难懂
M1 <- lmer(log(gdp) ~ REG + (1|country), data = dat2)
attach(dat2)
M1 <- lmer(log(gdp) ~ REG + (1|country), data = dat2)
